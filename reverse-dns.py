#!/usr/bin/env python

'''
This is an automated reverse DNS lookup script that utilizes
the functionality of "host" (man host for more information).
Use 'python reverse-dns.py -h for more usage details.
'''

import os
import sys
import re
import socket
import collections
import subprocess
import argparse

ip_range = None #ips to perform reverse lookups on
file = None #file to write to on if given, otherwise sys.stdout
host_results = collections.OrderedDict() #contains host lookups before parsing

def reverse_lookup():
    '''
    Performs the actual reverse lookup using
    the host tool
    '''
    global output

    #first split the given ip range
    ip_split = ip_range.split('.')
    foctets = '.'.join(ip_split[:3]) + "." #front otctets
    boctet = ip_split[-1].split('-') #back octet

    #now use host tool to perform reverse lookup in counting loop
    counter = int(boctet[0]) 
    while counter <= int(boctet[1]):
        try:
            host_results[str(foctets) + str(counter)] = subprocess.check_output(["host", str(foctets) + str(counter)])
        except subprocess.CalledProcessError: #will throw an exception when hitting host it can't find
            pass
        counter += 1

def parse_results():
    '''
    Parses the return of reverse_lookup() into
    something more readable
    '''
    for ip in host_results:
        result = host_results[ip]
        domains = re.findall(r'pointer\s([\w\.-]*).', result)
        host_results[ip] = domains

def write_to_file():
    '''
    If selected, will write result of reverse_lookup()
    to a designated file, otherwise to stdout
    '''
    for ip in host_results:
        domains = ''
        values = host_results[ip]
        while values:
            if len(values) > 1:
                domains += values.pop() + ', '
            else:
                domains += values.pop()

        file.write("[{ip}] ----- {domainnames}\n".format(ip=ip, domainnames=domains))

    if file != sys.stdout:
        file.flush()
        file.close()

def arg_parser():
    '''
    Parse command lines args
    '''
    global ip_range
    global file

    parser = argparse.ArgumentParser()
    parser.add_argument("-r", "--range", help="IP range to perform reverse lookup on. Format: 192.168.1.x-x, otherwise scans current subnet")
    parser.add_argument("-f", "--file", help="If you want to write to a file, supply absolute or relative path here, otherwise goes to stdout")
    args = parser.parse_args()

    ip_range = args.range
    file = args.file

def main():
    '''
    program entry
    '''
    global ip_range
    global file

    arg_parser()

    if not ip_range: #if no ip range is given, determine local subnet and get ready to scan it
        local_ip = socket.gethostbyname(socket.gethostname())
        netmask = local_ip.split('.')[:3]
        ip_range = ".".join(netmask) + ".1-254"

    if not file: #write to stdout if no file given
        file = sys.stdout
    else:
        if os.path.exists(file):
            if os.path.isfile(file):
                try:
                    file = open(file, "a")
                except (OSError, IOError):
                    perm_error = raw_input("Can not write to directory. Do you want to write to stdout instead? y/n: ")
                    if perm_error.lower() == 'y':
                        file = sys.stdout
                    if perm_error == 'n':
                        print "Quitting program..."
                        sys.exit(1)
                    else:
                        print "Quitting program..."
                        sys.exit(1)
            else:
                print "Given path is directory, not file. Please provide writable file name."
                sys.exit(1)
        else:
            no_file = raw_input("Can not find file. Do you want to write to stdout instead? y/n: ")
            if no_file.lower() == "y":
                file = sys.stdout
            elif no_file.lower() == "n":
                print "Quitting program..."
                sys.exit(1)
            else:
                print "Quitting program..."
                sys.exit(1)

    reverse_lookup()

    parse_results()
    
    write_to_file()

    print "Reverse DNS lookup successful. If you see no entries, none were found for the given IP range."
    print "Exiting program."

    sys.exit(0)

if __name__ == "__main__":
    main()
